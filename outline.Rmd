---
title: 'Introduction to R: Computer Programming for DNR Water Quality Professionals. Day 1'
author:
- "Aaron Ruesch"
- "Matt Diebel"
- "Alex Latzka"
output: ioslides_presentation

  
---

# Outline

# Day 1

----

## Logistics

1) Download the course pack using the following link:
    * <http://bit.ly/2s7uBzz>
    * Or copy it from one of the available flash drives
    * Save it wherever you'd like and extract the contents the zip file
2) Ensure RStudio and Excel are installed on your computer

----

## The plan for today

1) Why learn a computer language?
2) Neat things you can do with R
3) Tour of RStudio software
4) Basic R syntax

----

## Why learn a computer programming language?

### Do you work on a computer?

If so, it's likely you could benefit in some way by learning a programming language. Using a computer without programming skills is like:

* advocating for water quality without understanding the science: you may be able to change the behavior of a few people with your persuasion alone, but you will be much more effective if you can properly communicate the implications of poor water quality, its causes, and the opportunities for restoration.
* making pesto with a knife instead of a food processor: most of the time you're cutting each pine nut one at a time, and occasionally you can get a few all at once. With a food processor, it may take longer to set up, but once it's ready you can make a year's worth of pesto in 10 minutes and the result will be much more consistent.
* making cake with a wheat seed and a baby chicken: rather than beginning from raw materials every time, it would be more effective to first raise many egg-producing chickens, replicate your wheat seed into a field of seed-yielding plants, and build a tool for processing seeds into flour. 

## Okay, but What is so special about the R language?

* R will soon be the language preferred by most scientists. [Measured by Google Scholar hits](http://r4stats.com/articles/popularity "The Popularity of Data Science Software"), R recently surpassed SAS, and will soon surpass SPSS which has been trending precipitously downward for the last 7 years.
* R is extremely extensible. It was originally designed to be used solely for data analysis and graphics. However, the scope of its use has increased dramatically to include automation, interactivity with other languages, application and web development, GIS, database management, and much more. The key is the involvement of a large (and growing) user base that contributes to the project.
* R is free

## R can do all sorts of amazing things:

Insert some amazing things here

----

## Tour of RStudio

R comes in lots of different flavors, but the way that we will be using R for this class is through a software package called RStudio. RStudio packages many of the things you need to be a productive programmer all in place. RStudio can help beginner programmers learn quickly, but it also has enough functionality to satisfy the advanced programmer as well. To start, let's get a feel for the RStudio interface.


First, open RStudio software by clicking on the Windows Start button and typing "rstudio":

![](img/rstudio_screenshot.png)

----

There are a number of windows in R, but we are going to start by using only one, the R **console**:

![](img/r_console.png)

----

The R console allows you to type in R code interactively, line-by-line, and print the result. RStudio has many fancy functions, of which we will discuss in more detail as we go along, but basic R software (as opposed to RStudio) is essentially just the console, so you can mentally equate the R program with the mental image of the R console. It's a commmand prompt (```>```, the place where you type in code), plain and simple.

Let's try writing our first line of code. One of the most basic elements of any computer programming language is simple math. Try typing in 2+2 at the command prompt, and hit enter:

```{r}
2+2
```

Notice that the R console returns the result of that mathematical statement. There is a little bracketed ```[1]``` next to the result--all that means is that first item is list directly to the right--we will come back to this later, but for now you can ignore it.

### Exercise

Let's take 5 minutes to try out different mathemeatical statements. Try using different mathematical operators such as addition/subtraction (```+```, ```-```), multiplication/division ( ```*```, ```/```), and exponents (```^```), and parentheses.

----

### Variables

When we type in a mathematical statement in the R console and press enter, it returns the results as a message printed on the screen. As an alternative to having the result returned as a message, we can also save the result to be used later. We do this by **assigning** the result to a **variable**. To tell R to assign a value to a variable, We will use the equals sign (```=```):

```{r}
my_1st_variable = 5
```

Note that wa

We can name the variable anything we want. Here I named it ```my_1st_variable```, but I could just as well have named it ```theodore_roosevelt```, the only rules being that it cannot contain a space, special characters, or start with a number.

Think of a variable as a **container** that you can put anything into--you can also take things out or modify the contents, which is why they are called "variables". Once the contents are stored, we can re-use them as though they have the same value as the contents themselves:


```{r}
my_1st_variable + 5
```

As you create more and more variables, RStudio has a helpful tool for you to keep track of them. There is a tab called "Environment" in the upper-right panel that lists all of your variables for you.

![](./img/rstudio_environment_tab.png)

In the same way we write mathematical equations, variables take on the value of the right-hand side of the equation. For example:

```{r}
x = 2 + 2
x + 2
```

So what is the value of x?

*Note: we can use either an equals sign (```=```) or an arrow (```<-```)--which is just the less-than sign followed by a hyphen--to assign a variable. If you want to bring the purist trolls out of the woodwork, ask Google which one you should use. If you want to keep it simple, just pick one and stick with it. In other words, it really doesn't matter which one you use, just be aware of both when reading others' code*

*** Exercise

Take 5 minutes to try out variable assignment using mathematical operators. Try re-using variables in mathematical statements.

----

### scripts

You've probably begun to notice that it is tedious to write every statement of code, line-by-line, one-at-a-time, at the command prompt in the R console. Fortunately, you will not have to do this any longer. Enter the **script**.

A script contains many lines of code that can be executed simultaneously. It is a file stored on your hard drive, much like a .docx or .xlsx file, except it has a .r extension instead. 

RStudio has a feature that makes it very easy to create a script. In the file menu, click new file, and then click R script. A new blank pane should appear:

![](img/rstudio_script_pane.png)

We are going to save this file on our hard drive, but first, a little house cleaning. We've set up an RStudio **project** for you, which is simply a way of containing many useful elements relating to a project in one place. In the file menu, click Open Project, navigate to the place you stored the course pack, and select the file called "r_workshop.Rproj". Doing so will set up our R session to work out of our course pack folder. You can verify this by clicking the Files tab in the lower-right pane:

![](img/rstudio_files_tab.png)

A window like the one above should appear with files associated with our class.

Now, let's save our R script. Click the save button on our R script pane:

![](img/save_button.png)



Notice that RStudio recognizes certain characters and changes their colors. Although you are ultimately writing to a simple text file, because its file extension is ".r", RStudio recognizes that it contains R code, and then helps you visualize it through color. This is one helpful feature of an Integrated Development Environment, or IDE.

One of the most useful features of the RStudio IDE is the ability to run the code in your scripts in your console. With your cursor on the same line as the `print` statement, press `Ctrl+Enter`.

Another very helpful feature for increasing your productivity is tab completion. Try typing in the following text and hitting the tab button:

```{r}
"C:/
```

Notice that RStudio recognizes your file system.

#### Exercise (5 minutes)

See if you can use tab completion to find the folder containing the course pack.


---

### Functions

In the above two statements, we had to deduce the value of x:

```{r}
x = 2 + 2
x + 2
```

It is obvious that the value is 4 because of the simplicity of the statement, but our code is going to get more complex very quickly, so let's introduce a method for telling R to return the value of a variable. We are going to use a **function** called ```print```

```{r}
print(x)
```

An R function *does something*. It is an action statement. Functions are the **verbs** of computer programming. In the case of the above ```print``` function, its action is to print the value of ```x``` as a message to the user. 

The way we use functions in R is by typing their name followed by parentheses (without a space in between). The contents of the parentheses are called the **arguments**. Arguments are how we tell the function what to do. If "jump" were a function, the argument would by "how high?".

A simple function in R that you will likely use a lot is the ```sum``` function.


```{r}
sum(8, 3, 1)
```

The arguments of the above ```sum``` function are the values we want to add together. We seperate arguments of a function by inserting a comma between each.

Each function in R has its own set of arguments. That is, our metaphorical argument "how high?" for our "jump" function would not make sense for a "dance" function.

So how do we know what arguments to use for each function? We can use R help for that. There are two ways to access help for R functions. The first is to use the RStudios help tab in the lower-left pane:

![](img/rstudio_help_tab.png)

Or, we can simply type a question mark followed by the function name in our console:

```{r}
?print
```

A core function in R that you will become very familiar with is the ```c()``` function. The ```c()``` function allows you to create a vector of values. A vector is a sequence of values:

```{r}
y = c(3,5,7)
print(y)
```

In R, you can do math **across** vectors:

```{r}
z = y * 2
print(z)
```

This may not seem like much, but one of the most powerful aspects of R, and what sets it apart from many other computer programming languages is its ability to do math across sequences of numbers--it is what we refer to as an "array-based language".

### Exercise

Let's take 20 minutes to explore mathematical operators, variables, and functions. Try using vectors with other functions, such as the ```mean()``` and ```stdev()``` (standard deviation) functions.

----

#### The ```data.frame```

If you are accustomed to using Excel or Access, the data.frame object in R should be very intuitive for you. A data.frame is just a table of data. In a data.frame, each column has a name and number that identify the data in it, and the data within a column is all the same type (e.g., letters cannot be mixed with numbers---more on this later). Before we use data.frames in R, let's look at the table that we'd like to use in R. Open the `data_frame.csv` file in Excel and familiarize yourself with the data.

Now we want to read that data into R. To do this, we will use the `read.csv` function. If you remember, a function does something within the context of the arguments passed to it. The `print` function had only one argument, the message to be printed, but the `read.csv` function has several more. Let's take a look at what those arguments are by introducing a new concept in R---the help menu. To access the help menu for any function, all you have to do is type a question mark followed by the function name into the console. For example:

```{r}
?read.csv
```


The help menu for this function should appear in one of the panels in RStudio. You'll notice that the help menu shows the usage of `read.csv` and some similar functions, and a specific section with descriptions of each argument - `read.csv` has quite a few. The syntax with passing arguments to a function is the function name, with parentheses, and within the parentheses all arguments separated by commas. You can see this syntax in the Usage section. You'll notice in the help menu that the first argument is `file`. This tells R where in your file system the table is located, and is required for the function to run. All of the other arguments (`header`,`sep`,etc.), have default values and are thus not required to be entered by the user. Default values are shown in the Usage section with an `=` sign: `read.csv(file,header=TRUE)`, and additional details provided in the Arguments section.

Let's use what we've learned about read.csv to load in a data.frame

```{r}

d = read.csv("data/TP_CHL_models.csv")
```


Once we have the data.frame read into R and saved as an object, it is often useful to view it, check that the data were read in correctly, check column names, check numbers of rows and columns, etc. Since you don't always have a spreadsheet of the data in front of you while working in R, it's useful to become familiar with interpreting these attributes of your data. We can explore our data.frame in a few ways. 

First, let's introduce a few very useful functions. `str` (meaning "structure") is one you should become very fluent in. For a data.frame, it only requires one argument: the name of your data.frame. Thus, `str(df)` returns a few useful items, the number of observations (rows) and variables (columns), the name of each column, whether each column is numeric, integer, etc. (more on data.types next), and the first several entries of each column.

Sometimes, it's easier to just look at the data.frame in table form though. To do that, we can just run `print(df)` or `df` for short. This will print the data.frame in the console, but gets very messy if you have more than a few rows or columns. One way to get around that is to use `head` or `tail` which only show you the top or bottom of your data.frame, but can still be messy if we have many columns. Finally, RStudio has another nice feature that lets us view our data.frame a little more like a spreadsheet - just double-click on the name of your data.frame in the Environment window or use `View(df)`. 

If we just want to see the names of the variables, we can use `names` or `colnames`. 
Finally, we may want some idea of how big our data.frame is. To get the number of rows, use `nrow`. For the number of columns, use `ncol`. 

What if we just want to look at a particular column? You may have noticed that the names of each variable in the output of the `str` command are preceded by a `$`. We can use this to reference particular columns by name. Say we have a column named "TP" within a data.frame named "LakeMendota". To access and run functions on just those TP values, we can reference them directly using `LakeMendota$TP`. We'll come back to subsetting data.frames a bit later. 

#### Exercise (10 min)
Try running `read.csv` using your `filename` variable, and saving the data to a new variable. To verify that it read correctly, either use the `print` function, or click on your new variable in the *Environment Panel*. Try reading subsets of the table by using the `nrows` and `skip` arguments. Explore your data.frame using `str`,`head`,`tail`,`names`,`colnames`,`nrow`, and `ncol` functions, and access specific columns with `$`. 

*Hint:* The arguments should be listed in the same order as they are in the help menu, unless they are specifically set with an equals (`=`) operator. For example, the first argument to `read.csv` is the file---we can just enter the file first 
  
### Data types

Let's say you are working in Excel, and you want to create a column that contains quantities of money associated with different people.

![](img/excel_money_example.png)


For the purposes of printing, you would like to format the quantities with a dollar sign in front of the value, with two significant digits to represent cents

![](img/excel_money_example_formatted.png)

Now, let's say you need to populate one of the records with a value of "unknown", so you type in the characters u-n-k-n-o-w-n. Now, when you try to format that column with a dollar sign and two significant digits, Excel returns an error for the field containing the "unknown" value.



This is because Excel does not recognize the "unknown" value when formatting the whole column as currency. The "unknown" value is a different date **type**. The formatting function in Excel only recognizes numeric data types and therefore throws in error, and R will do the same with mismatches in data types.

We are going to talk about 4 main data types in R:

#### Numbers

The two data types that represent numbers are "numeric" and "integer". A numeric data type is a quantity with a decimal point (sometimes referred to as "float" or "double" in other programming languages), and an integer is a quantity without a decimal point, simple as that! You can use the ```class``` function to query the data type of a value:

```{r}
class(1.5)
class(1)
```

Notice that value of 1 is defined as a numeric data type. If you want to be explicit about defining an integer, you must use a **coercion** function. Each data type has a coercion function--the name of the function is just the data type preceded by ```as.```, such as ```as.numeric``` or ```as.integer```.

```{r}
class(as.integer(1))
```

#### Characters

"Characters" (often referred to as "strings" in other programming languages) can include alphabet letters, digits, and special symbols, but are all treated as text. Characters can be defined by wrapping them in quotes:

```{r}
class("This is a character data type")
class("Numbers (1) and symbols ($) can be included in characters")
class("1")
```

You can also coerce a value to a character using its coercion function:

```{r}
char_var = as.character(1.52342)
print(char_var)
class(char_var)
```

#### Logical

The final data type we'll talk about today is the "logical" data type. The logical data type is the simplest because it can take on only two values, TRUE and FALSE:

```{r}
class(TRUE)
```

The values TRUE and FALSE are only considered logical data type if written in these ways:

```{r}
# All caps
class(TRUE)
class(FALSE)
# Capital T or F
class(T)
class(F)
# 0 or 1
class(as.logical(0))
class(as.logical(1))
```

#### Data types and data frames

Data types become more important in data frames. In a data frame, a column can only contain values of a single data type. For example, a column intended to contain numeric data (such as the money column in our Excel table) 

#### Exercise

Take 5 minutes to test different functionality on different data types to see how R behaves (for example, try dividing an integer or multiplying by a character).

----

###

```{r}
# At some point on day 2 before my data management section, I presume we will be reading in one of the course datasets. 
d = read.csv("data/Vilas_TP_CHL_data.csv")
```

A data frame has rows and columns. Each column contains data of the same **type**. R has several data types including:



We can easily view the data types of a data frame using the ```str``` function:

```{r}
str(d)
```



Strings, numbers, integers
* Each column has a data type show ```str()```--define data types

#### Slicing, subsetting

#### Scatterplot
        * Make a scatterplot
        
A HUGE benefit of using R is its ability to produce customizable, complex, and downright pretty visualizations of data. A drawback of a 2-day workshop is that we can't quite teach you all of that. We can teach you the basics, which act as building blocks toward higher-level graphics. 

We'll come back to making figures tomorrow, but by this point in the workshop, you've earned the right to see what the data look like outside of a data.frame. The key building block in making graphics is the `plot` function. This is a highly versatile function - it can take lots of different data and object types as inputs. The default usage is to just give it x and y coordinates in the form `plot(x,y)`, and it will output a scatterplot. In RStudio, this will show up in its own panel. The `x` and `y` arguments can be single values, vectors of values, or columns from a data.frame.   
        
#### Exercise (10 min)
Use your data.frame to play around with making simple scatterplots. Try to integrate some of your knowledge of data subsetting to remake the plot for different lakes. 


4. Exercise
    - Open the text file but try other arguments
    - Plot the data using different plot arguments


#### For loops


# Exercise

Lots of scatterplots, one big pdf

## Day 2, Using R in your work

### Logistics

1) Download the course pack using the following link:
    * <http://bit.ly/2s7uBzz>
    * Or copy it from one of the available flash drives
    * Save it wherever you'd like and extract the contents the zip file

```{r}
# We should have a script here that ensures all attendees have the same working directory, variables, etc.
# Have them run this at the beginning of class
d = read.csv("data/TP_CHL_models.csv")
```

#### More detailed plotting

Yesterday, we showed you how to make simple scatterplots. But, there are numerous other types of plots you can make, infinite ways to customize them, and some techniques for creating publication or web-quality figure. Today, we'll introduce  you to a bit of all of the above. 

#####Other plot types

The basic `plot` command is versatile and can take various types of input arguments, but there are other functions. For instance, if you want to make a boxplot, then the `boxplot` command might suit you. If you want to make a histogram, `hist` is probably a good option. Let's try these.

boxplot of something in the dataframe

hist of something in the dataframe

These and many other functions exist, and they're not too hard to find. Just google them (e.g., "R histogram"). Feel free to try to find other plot types that you can make in R on your own. For now though, let's go back to our basic scatterplot and learn how to customize it (aka, add complexity and make it pretty). 

First, let's say we want to make a scatterplot with an overlayed line that compares our points to an existing model. The general approach in R is to first create your simple plot, and then add features to it. You can add features with a number of functions, including `lines`, `points`, `polygon`, and more. These don't create plots on their own - they add lines, points, or a polygon to a plot that has already been made and is currently active. To make a scatterplot with an overlayed fit line, we can use the data.frame from our project file. We first create our scatterplot with `plot(df$TP,df$Chl)`. Then, we can use the 2nd data.frame from our project folder, which already has x (TP) and y (Chl) coordinates corresponding to a widely used model, to create a line with `lines(model$TP,model$Chl)`. 

Great, now you have a multi-layer plot. 'Tis a shame that it's pretty ugly! Let's spruce it up. You may have noticed that in the help file for `plot`, there are a number of additional arguments, including things like `xlab` and `ylab` to name your axes and `main` to name the plot title. These arguments that require text strings can be set like so: `plot(x,y,xlab="Date",ylab="TP (mg/L)")`. 

Then, in the help files for `plot`,`lines`, etc., there is something called "Further graphical parameters (see par)...". `par` is essentially a set of default graphical parameters that can be reset, or that can be changed for the current plot within the plot command. Use `?par` to see the numerous options. We won't walk through all of them now, but it is worth exploring these options if you want to fully customize your plots. For now, here is a table with a few of the most commonly used arguments

  some table here with col, pch, cex, lty, lwd
  
Each of the arguments can be set within a call to a plotting command (e.g., `plot(x,y,col="black",cex=1.5,pch=21)). Generally, a simple way to find what line or point types are available, and their corresponding codes, is to google it (or google image): "r pch" or "r lty". Colors can be pretty intuitive ("black","red", etc.). You can also google image "r colors" to see a bunch of other pre-named colors you can access, or you can provide RGB codes in the form "#RRGGBB", or use existing color palettes and functions (e.g. (rainbow). 

There are some arguments that can only be set in a specific call to the par function. Say we don't want a title, and we want to eliminate the space above the plot where the title would be. To do that, we need to remove the space that R creates above the plot by default, and we can do that with a `par` argument called `mar`. `mar` takes a vector of 4 values, where each is the number of lines of space provided on each side of the plot in the form c(bottom, left, top, right). The default is c(5.1,4.1,4.1,2). So, R is provided 4.1 lines of space above the plot (the 3rd value in that vector). To reduce that to something small, we just reset its value in par: `par(mar=c(5.1,4.1,0.5,2))`. 

One of the things that `par` allows us to do is multi-panel plotting. Perhaps you noticed that each time you ran the `plot` function, the previous plot was overwritten. What if you wanted two plots on the same figure, next to each other. Before creating the first plot, we can use `par` to tell R that we're going to create 2 plots in the figure. There are two `par` arguments that control this: `mfrow` and `mfcol`. I think of the "mf" as "multiple figures" and "col" or "row" to indicate the number of columns or rows, respectively, and how many items in each one. Thus, `par(mfrow=c(3,2))` creates a 6-panel plot with 3 rows of 2 items (columns) each. To make two plots side-by-side, we can use `par(mfrow=c(1,2))`. 

Finally, what if we want to save our plot so that it exists outside of our R session? The recommended strategy is to use a graphic devices function, which give you full control over dimensions, resolution, background color, etc. The functions are named pretty intuitively: `pdf`, `png`, `jpeg`, `tiff`, etc. The arguments include: filename, width, height, units, and res. Units can be "px" (default), "in", "cm", or "mm" - for images that I use in powerpoints or documents, I generally use "in", as these are typically easy to fit onto a slide or a page. Then, you can set width and height to typical dimensions (width=6,height=4). "res" defines the dots/pixels per inch for bitmap type images. Generally, 150 is sufficient for presentations, 300 is good for print, but some publications require higher. "filename" is whatever you want to name the file with the appropriate file extension, which will be saved to the working directory, or you can supply the path and filename to save it elsewhere. 

Now that you know what information to give the graphic device function, how does it work in conjunction with your plotting code. When you run a `png` function for instance, nothing seems to happen in RStudio. However, behind the scenes, R opens a new graphical device, onto which all the subsequent lines of code will be run and plotted. At the end of those lines of code, we need to tell R to stop the plotting and save the .png file. We can do this by telling R to shut off the graphical device. We can do that by running `dev.off`. Let's see how all this comes together to create and save a figure...

 #show example here

#### Exercise
Whoever makes the prettiest plot wins! (By entirely subjective standards, of course)

Play around with creating and customizing prettier plots in R, starting with the data.frames you worked with yesterday. Play with the settings for axes, colors, point and line types, point sizes and line widths, margin sizes, multipanel plots, and saving them. 

a.	More detailed plotting (Yellow)
  i. boxplots
  ii. histogram
  iii. multilayer plots, points with lines, etc.
  iv. axes, labels, other plotting arguments
  v. saving plots (png, pdf)
  vi. exercise

b. Simple Stats (Matt)
  i. Regression
  ii. t-test
  iii. Two-way ANOVA
  iv. Model objects
    1. Re-hash the str() object
    2. summary
    3. p-values
    4. residuals
    5. r.squared
  v.	exercise

----

### Data management

#### Philosophies/Rules

Say you have a task where you need to retrieve a dataset, manipulate the data in a multi-step process, analyze the manipulated data, and return a result. One way to accomplish this task would be to use Excel. If you choose to use Excel, and most of your colleagues use Excel as well, your workflow may look something like this:

1. Open a second-hand .xlsx file, try to understand what the names of the worksheets mean, and hope you select the correct data given that there are bits of fragmented tables strewn about.
2. Create a new .xlsx file, copy and paste your data into it, and save.
3. Create several new worksheets in your .xlsx file, each associated with an intermediate calculation.
4. Send your third-hand .xlsx file to your client/colleague, and they will repeat the above process for their task.

With your new R skills (and working with your colleagues with new R skills), you will be able to improve your workflow to look something like this:

1. Retrieve your data from the original source.
2. Write a script that contains all intermediate processing steps without needing to save any intermediate data.
3. Send your results to your client in a simple, text-based file format such as tab-delimited.

The benefits of the R-driven process is this:

1. Each step in your retrieval, manipultation, analysis, and delivery process is well-documented and repeatable.
2. You are confident you are using the correct data, you have not altered the original data in the process, and you have not created any uneccessary clutter on your hard-drive with intermediate data files.
3. Your data result will be readable 20-30 years from now even though Excel has been deprecated.

To distill the above process, here are a few general guidelines:

1. Refer to the original dataset without altering it
2. Create as few intermediate datasets as possible
3. Save your product in a simple, timeless data format

There are, of course, exceptions to the above rules, but these 3 will serve you well for most tasks.

Let's look at an example workflow using wastewater Discharge Monitoring Report data (DMR):


ii. Pull in multiple tables
  iii. RODBC or ROracle 
    1. Introduce packages
      a. Use base R when possible
      b. Could be worthwhile to learn certain packages rather coding yourself from base functions
      c. Resources for learning new packages

d. MORE WOW FACTOR (everyone contributes)
  i. Shiny
  ii. Spatial Analysis
  iii. Advanced plotting
  iv. Advanced statistics (e.g., ordination, CART, vegan)

e. Tying everything together exercise
  i. Pull in large datasets
  ii. For loop
  iii. Subset
  iv. Fit regression
  v. Scatterplot with abline()
